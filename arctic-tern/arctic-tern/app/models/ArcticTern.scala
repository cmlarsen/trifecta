/**
 * Generated by apidoc - http://www.apidoc.me
 * Service version: 0.0.3
 * apidoc:0.11.19 http://www.apidoc.me/trifectalabs/arctic-tern/0.0.3/play_2_x_json
 */
package com.trifectalabs.arctic.tern.v0.models {

  /**
   * Object used to respond to health checks
   */
  case class HealthCheck(
    status: String
  )

  case class Point(
    lat: Double,
    long: Double
  )

  case class Route(
    id: Int,
    polyline: String,
    targetdistance: Double,
    targetelevation: Double,
    actualdistance: Double,
    actualelevation: Double,
    cost: Double
  )

}

package com.trifectalabs.arctic.tern.v0.models {

  package object json {
    import play.api.libs.json.__
    import play.api.libs.json.JsString
    import play.api.libs.json.Writes
    import play.api.libs.functional.syntax._
    import com.trifectalabs.arctic.tern.v0.models.json._

    private[v0] implicit val jsonReadsUUID = __.read[String].map(java.util.UUID.fromString)

    private[v0] implicit val jsonWritesUUID = new Writes[java.util.UUID] {
      def writes(x: java.util.UUID) = JsString(x.toString)
    }

    private[v0] implicit val jsonReadsJodaDateTime = __.read[String].map { str =>
      import org.joda.time.format.ISODateTimeFormat.dateTimeParser
      dateTimeParser.parseDateTime(str)
    }

    private[v0] implicit val jsonWritesJodaDateTime = new Writes[org.joda.time.DateTime] {
      def writes(x: org.joda.time.DateTime) = {
        import org.joda.time.format.ISODateTimeFormat.dateTime
        val str = dateTime.print(x)
        JsString(str)
      }
    }

    implicit def jsonReadsArcticTernHealthCheck: play.api.libs.json.Reads[HealthCheck] = {
      (__ \ "status").read[String].map { x => new HealthCheck(status = x) }
    }

    def jsObjectHealthCheck(obj: com.trifectalabs.arctic.tern.v0.models.HealthCheck) = {
      play.api.libs.json.Json.obj(
        "status" -> play.api.libs.json.JsString(obj.status)
      )
    }

    implicit def jsonWritesArcticTernHealthCheck: play.api.libs.json.Writes[HealthCheck] = {
      new play.api.libs.json.Writes[com.trifectalabs.arctic.tern.v0.models.HealthCheck] {
        def writes(obj: com.trifectalabs.arctic.tern.v0.models.HealthCheck) = {
          jsObjectHealthCheck(obj)
        }
      }
    }

    implicit def jsonReadsArcticTernPoint: play.api.libs.json.Reads[Point] = {
      (
        (__ \ "lat").read[Double] and
        (__ \ "long").read[Double]
      )(Point.apply _)
    }

    def jsObjectPoint(obj: com.trifectalabs.arctic.tern.v0.models.Point) = {
      play.api.libs.json.Json.obj(
        "lat" -> play.api.libs.json.JsNumber(obj.lat),
        "long" -> play.api.libs.json.JsNumber(obj.long)
      )
    }

    implicit def jsonWritesArcticTernPoint: play.api.libs.json.Writes[Point] = {
      new play.api.libs.json.Writes[com.trifectalabs.arctic.tern.v0.models.Point] {
        def writes(obj: com.trifectalabs.arctic.tern.v0.models.Point) = {
          jsObjectPoint(obj)
        }
      }
    }

    implicit def jsonReadsArcticTernRoute: play.api.libs.json.Reads[Route] = {
      (
        (__ \ "id").read[Int] and
        (__ \ "polyline").read[String] and
        (__ \ "targetdistance").read[Double] and
        (__ \ "targetelevation").read[Double] and
        (__ \ "actualdistance").read[Double] and
        (__ \ "actualelevation").read[Double] and
        (__ \ "cost").read[Double]
      )(Route.apply _)
    }

    def jsObjectRoute(obj: com.trifectalabs.arctic.tern.v0.models.Route) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsNumber(obj.id),
        "polyline" -> play.api.libs.json.JsString(obj.polyline),
        "targetdistance" -> play.api.libs.json.JsNumber(obj.targetdistance),
        "targetelevation" -> play.api.libs.json.JsNumber(obj.targetelevation),
        "actualdistance" -> play.api.libs.json.JsNumber(obj.actualdistance),
        "actualelevation" -> play.api.libs.json.JsNumber(obj.actualelevation),
        "cost" -> play.api.libs.json.JsNumber(obj.cost)
      )
    }

    implicit def jsonWritesArcticTernRoute: play.api.libs.json.Writes[Route] = {
      new play.api.libs.json.Writes[com.trifectalabs.arctic.tern.v0.models.Route] {
        def writes(obj: com.trifectalabs.arctic.tern.v0.models.Route) = {
          jsObjectRoute(obj)
        }
      }
    }
  }
}

package com.trifectalabs.arctic.tern.v0 {

  object Bindables {

    import play.api.mvc.{PathBindable, QueryStringBindable}
    import org.joda.time.{DateTime, LocalDate}
    import org.joda.time.format.ISODateTimeFormat
    import com.trifectalabs.arctic.tern.v0.models._

    // Type: date-time-iso8601
    implicit val pathBindableTypeDateTimeIso8601 = new PathBindable.Parsing[org.joda.time.DateTime](
      ISODateTimeFormat.dateTimeParser.parseDateTime(_), _.toString, (key: String, e: Exception) => s"Error parsing date time $key. Example: 2014-04-29T11:56:52Z"
    )

    implicit val queryStringBindableTypeDateTimeIso8601 = new QueryStringBindable.Parsing[org.joda.time.DateTime](
      ISODateTimeFormat.dateTimeParser.parseDateTime(_), _.toString, (key: String, e: Exception) => s"Error parsing date time $key. Example: 2014-04-29T11:56:52Z"
    )

    // Type: date-iso8601
    implicit val pathBindableTypeDateIso8601 = new PathBindable.Parsing[org.joda.time.LocalDate](
      ISODateTimeFormat.yearMonthDay.parseLocalDate(_), _.toString, (key: String, e: Exception) => s"Error parsing date $key. Example: 2014-04-29"
    )

    implicit val queryStringBindableTypeDateIso8601 = new QueryStringBindable.Parsing[org.joda.time.LocalDate](
      ISODateTimeFormat.yearMonthDay.parseLocalDate(_), _.toString, (key: String, e: Exception) => s"Error parsing date $key. Example: 2014-04-29"
    )



  }

}
